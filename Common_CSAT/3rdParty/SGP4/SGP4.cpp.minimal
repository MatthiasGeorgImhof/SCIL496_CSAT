/*     ----------------------------------------------------------------
 *
 *                               sgp4unit.cpp
 *
 *    this file contains the sgp4 procedures for analytical propagation
 *    of a satellite. the code was originally released in the 1980 and 1986
 *    spacetrack papers. a detailed discussion of the theory and history
 *    may be found in the 2006 aiaa paper by vallado, crawford, hujsak,
 *    and kelso.
 *
 *                            companion code for
 *               fundamentals of astrodynamics and applications
 *                                    2022
 *                              by david vallado
 *
 *    email dvallado@comspoc.com, davallado@gmail.com
 *
 *    current :
 *              29 aug 24  david vallado
 *                           add check for sgp4-xp tle
 *    changes :
 *              12 mar 20  david vallado
 *                           chg satnum to string for alpha 5 or 9-digit
 *               7 dec 15  david vallado
 *                           fix jd, jdfrac
 *               3 nov 14  david vallado
 *                           update to msvs2013 c++
 *              30 aug 10  david vallado
 *                           delete unused variables in initl
 *                           replace pow integer 2, 3 with multiplies for speed
 *               3 nov 08  david vallado
 *                           put returns in for error codes
 *              29 sep 08  david vallado
 *                           fix atime for faster operation in dspace
 *                           add operationmode for afspc (a) or improved (i)
 *                           performance mode
 *              16 jun 08  david vallado
 *                           update small eccentricity check
 *              16 nov 07  david vallado
 *                           misc fixes for better compliance
 *              20 apr 07  david vallado
 *                           misc fixes for constants
 *              11 aug 06  david vallado
 *                           chg lyddane choice back to strn3, constants, misc doc
 *              15 dec 05  david vallado
 *                           misc fixes
 *              26 jul 05  david vallado
 *                           fixes for paper
 *                           note that each fix is preceded by a
 *                           comment with "sgp4fix" and an explanation of
 *                           what was changed
 *              10 aug 04  david vallado
 *                           2nd printing baseline working
 *              14 may 01  david vallado
 *                           2nd edition baseline
 *                     80  norad
 *                           original baseline
 *       ----------------------------------------------------------------      */

// https://github.com/CelesTrak/fundamentals-of-astrodynamics/blob/main/software/cpp/SGP4/SGP4/SGP4.cpp

#include "SGP4.h"

#define pi 3.14159265358979323846f

// define global variables here, not in .h
// use extern in main
char help = 'n';
FILE *dbgfile;

namespace SGP4Funcs
{

	/* ----------- local functions - only ever used internally by sgp4 ---------- */

	static void initl(
		// sgp4fix satn not needed. include in satrec in case needed later
		// int satn,
		// sgp4fix just pass in xke and j2
		// gravconsttype whichconst,
		float xke, float j2,
		float ecco, float epoch, float inclo, float no_kozai, char /* opsmode */,
		float &ainv, float &ao, float &con41, float &con42, float &cosio,
		float &cosio2, float &eccsq, float &omeosq, float &posq,
		float &rp, float &rteosq, float &sinio, float &gsto, float &no_unkozai);

	/*-----------------------------------------------------------------------------
	*
	*                           procedure initl
	*
	*  this procedure initializes the spg4 propagator. all the initialization is
	*    consolidated here instead of having multiple loops inside other routines.
	*
	*  author        : david vallado                  719-573-2600   28 jun 2005
	*
	*  inputs        :
	*    satn        - satellite number - not needed, placed in satrec
	*    xke         - reciprocal of tumin
	*    j2          - j2 zonal harmonic
	*    ecco        - eccentricity                           0.0f - 1.0
	*    epoch       - epoch time in days from jan 0, 1950. 0 hr
	*    inclo       - inclination of satellite
	*    no          - mean motion of satellite
	*
	*  outputs       :
	*    ainv        - 1.0f / a
	*    ao          - semi major axis
	*    con41       -
	*    con42       - 1.0f - 5.0f cosf(i)
	*    cosio       - cosine of inclination
	*    cosio2      - cosio squared
	*    eccsq       - eccentricity squared
	*    omeosq      - 1.0f - ecco * ecco
	*    posq        - semi-parameter squared
	*    rp          - radius of perigee
	*    rteosq      - square root of (1.0f - ecco*ecco)
	*    sinio       - sine of inclination
	*    gsto        - gst at time of observation               rad
	*    no          - mean motion of satellite
	*
	*  locals        :
	*    ak          -
	*    d1          -
	*    del         -
	*    adel        -
	*    po          -
	*
	*  coupling      :
	*    getgravconst- no longer used
	*    gstime      - find greenwich sidereal time from the julian date
	*
	*  references    :
	*    hoots, roehrich, norad spacetrack report #3 1980
	*    hoots, norad spacetrack report #6 1986
	*    hoots, schumacher and glover 2004
	*    vallado, crawford, hujsak, kelso  2006
	----------------------------------------------------------------------------*/

	static void initl(
		// sgp4fix satn not needed. include in satrec in case needed later
		// int satn,
		// sgp4fix just pass in xke and j2
		// gravconsttype whichconst,
		float xke, float j2,
		float ecco, float epoch, float inclo, float no_kozai, char /* opsmode */,
		float &ainv, float &ao, float &con41, float &con42, float &cosio,
		float &cosio2, float &eccsq, float &omeosq, float &posq,
		float &rp, float &rteosq, float &sinio, float &gsto, float &no_unkozai)
	{
		/* --------------------- local variables ------------------------ */
		float ak, d1, del, adel, po, x2o3;

		/* ----------------------- earth constants ---------------------- */
		// sgp4fix identify constants and allow alternate values
		// only xke and j2 are used here so pass them in directly
		// getgravconst( whichconst, tumin, mu, radiusearthkm, xke, j2, j3, j4, j3oj2 );
		x2o3 = 2.0f / 3.0f;

		/* ------------- calculate auxillary epoch quantities ---------- */
		eccsq = ecco * ecco;
		omeosq = 1.0f - eccsq;
		rteosq = sqrtf(omeosq);
		cosio = cosf(inclo);
		cosio2 = cosio * cosio;

		/* ------------------ un-kozai the mean motion ----------------- */
		ak = powf(xke / no_kozai, x2o3);
		d1 = 0.75f * j2 * (3.0f * cosio2 - 1.0f) / (rteosq * omeosq);
		del = d1 / (ak * ak);
		adel = ak * (1.0f - del * del - del * (1.0f / 3.0f + 134.0f * del * del / 81.0f));
		del = d1 / (adel * adel);
		no_unkozai = no_kozai / (1.0f + del);

		ao = powf(xke / (no_unkozai), x2o3);
		sinio = sinf(inclo);
		po = ao * omeosq;
		con42 = 1.0f - 5.0f * cosio2;
		con41 = -con42 - cosio2 - cosio2;
		ainv = 1.0f / ao;
		posq = po * po;
		rp = ao * (1.0f - ecco);

		gsto = gstime_SGP4(epoch + 2433281.5f);

		// #include "debug5.cpp"
	} // initl

	/*-----------------------------------------------------------------------------
	*
	*                             procedure sgp4init
	*
	*  this procedure initializes variables for sgp4.
	*
	*  author        : david vallado                  719-573-2600   28 jun 2005
	*
	*  inputs        :
	*    opsmode     - mode of operation afspc or improved 'a', 'i'
	*    whichconst  - which set of constants to use  72, 84
	*    satn        - satellite number
	*    bstar       - sgp4 type drag coefficient              kg/m2er
	*    ecco        - eccentricity
	*    epoch       - epoch time in days from jan 0, 1950. 0 hr
	*    argpo       - argument of perigee (output if ds)
	*    inclo       - inclination
	*    mo          - mean anomaly (output if ds)
	*    no          - mean motion
	*    nodeo       - right ascension of ascending node
	*
	*  outputs       :
	*    satrec      - common values for subsequent calls
	*    return code - non-zero on error.
	*                   1 - mean elements, ecc >= 1.0f or ecc < -0.001 or a < 0.95 er
	*                   2 - mean motion less than 0.0
	*                   3 - pert elements, ecc < 0.0f  or  ecc > 1.0
	*                   4 - semi-latus rectum < 0.0
	*                   5 - epoch elements are sub-orbital
	*                   6 - satellite has decayed
	*
	*  locals        :
	*    cnodm  , snodm  , cosim  , sinim  , cosomm , sinomm
	*    cc1sq  , cc2    , cc3
	*    coef   , coef1
	*    cosio4      -
	*    day         -
	*    dndt        -
	*    em          - eccentricity
	*    emsq        - eccentricity squared
	*    eeta        -
	*    etasq       -
	*    gam         -
	*    argpm       - argument of perigee
	*    nodem       -
	*    inclm       - inclination
	*    mm          - mean anomaly
	*    nm          - mean motion
	*    perige      - perigee
	*    pinvsq      -
	*    psisq       -
	*    qzms24      -
	*    rtemsq      -
	*    s1, s2, s3, s4, s5, s6, s7          -
	*    sfour       -
	*    ss1, ss2, ss3, ss4, ss5, ss6, ss7         -
	*    sz1, sz2, sz3
	*    sz11, sz12, sz13, sz21, sz22, sz23, sz31, sz32, sz33        -
	*    tc          -
	*    temp        -
	*    temp1, temp2, temp3       -
	*    tsi         -
	*    xpidot      -
	*    xhdot1      -
	*    z1, z2, z3          -
	*    z11, z12, z13, z21, z22, z23, z31, z32, z33         -
	*
	*  coupling      :
	*    getgravconst-
	*    initl       -
	*    dscom       -
	*    dpper       -
	*    dsinit      -
	*    sgp4        -
	*
	*  references    :
	*    hoots, roehrich, norad spacetrack report #3 1980
	*    hoots, norad spacetrack report #6 1986
	*    hoots, schumacher and glover 2004
	*    vallado, crawford, hujsak, kelso  2006
	----------------------------------------------------------------------------*/

	bool sgp4init(
		gravconsttype whichconst, char opsmode, const char satn[5], const float epoch,
		const float xbstar, const float xndot, const float xnddot, const float xecco, const float xargpo,
		const float xinclo, const float xmo, const float xno_kozai,
		const float xnodeo, elsetrec &satrec)
	{
		/* --------------------- local variables ------------------------ */
		float ao, ainv, con42, cosio, sinio, cosio2, eccsq,
			omeosq, posq, rp, rteosq,
			cc1sq,
			cc2, cc3, coef, coef1, cosio4,
			eeta, etasq,
			perige, pinvsq, psisq, qzms24,
			sfour,
			temp, temp1, temp2, temp3, tsi,
			xhdot1,
			qzms2t, ss, x2o3, r[3], v[3],
			delmotemp, qzms2ttemp, qzms24temp;

		/* ------------------------ initialization --------------------- */
		// sgp4fix divisor for divide by zero check on inclination
		// the old check used 1.0f + cosf(pi-1.0e-9), but then compared it to
		// 1.5f e-12, so the threshold was changed to 1.5e-12 for consistency
		constexpr float temp4 = 1.5e-12f;

		/* ----------- set all near earth variables to zero ------------ */
		satrec.isimp = 0;
		satrec.aycof = 0.0f;
		satrec.con41 = 0.0f;
		satrec.cc1 = 0.0f;
		satrec.cc4 = 0.0f;
		satrec.cc5 = 0.0f;
		satrec.d2 = 0.0f;
		satrec.d3 = 0.0f;
		satrec.d4 = 0.0f;
		satrec.delmo = 0.0f;
		satrec.eta = 0.0f;
		satrec.argpdot = 0.0f;
		satrec.omgcof = 0.0f;
		satrec.sinmao = 0.0f;
		satrec.t = 0.0f;
		satrec.t2cof = 0.0f;
		satrec.t3cof = 0.0f;
		satrec.t4cof = 0.0f;
		satrec.t5cof = 0.0f;
		satrec.x1mth2 = 0.0f;
		satrec.x7thm1 = 0.0f;
		satrec.mdot = 0.0f;
		satrec.nodedot = 0.0f;
		satrec.xlcof = 0.0f;
		satrec.xmcof = 0.0f;
		satrec.nodecf = 0.0f;

		/* ------------------------ earth constants ----------------------- */
		// sgp4fix identify constants and allow alternate values
		// this is now the only call for the constants
		getgravconst(whichconst, satrec.tumin, satrec.mus, satrec.radiusearthkm, satrec.xke,
					 satrec.j2, satrec.j3, satrec.j4, satrec.j3oj2);

		//-------------------------------------------------------------------------

		satrec.error = 0;
		satrec.operationmode = opsmode;
		// new alpha5 or 9-digit number
		strcpy(satrec.satnum, satn);

		// sgp4fix - note the following variables are also passed directly via satrec.
		// it is possible to streamline the sgp4init call by deleting the "x"
		// variables, but the user would need to set the satrec.* values first. we
		// include the additional assignments in case twoline2rv is not used.
		satrec.bstar = xbstar;
		// sgp4fix allow additional parameters in the struct
		satrec.ndot = xndot;
		satrec.nddot = xnddot;
		satrec.ecco = xecco;
		satrec.argpo = xargpo;
		satrec.inclo = xinclo;
		satrec.mo = xmo;
		// sgp4fix rename variables to clarify which mean motion is intended
		satrec.no_kozai = xno_kozai;
		satrec.nodeo = xnodeo;

		// single averaged mean elements
		satrec.am = satrec.em = satrec.im = satrec.Om = satrec.mm = satrec.nm = 0.0f;

		/* ------------------------ earth constants ----------------------- */
		// sgp4fix identify constants and allow alternate values no longer needed
		// getgravconst( whichconst, tumin, mu, radiusearthkm, xke, j2, j3, j4, j3oj2 );
		ss = 78.0f / satrec.radiusearthkm + 1.0f;
		// sgp4fix use multiply for speed instead of pow
		qzms2ttemp = (120.0f - 78.0f) / satrec.radiusearthkm;
		qzms2t = qzms2ttemp * qzms2ttemp * qzms2ttemp * qzms2ttemp;
		x2o3 = 2.0f / 3.0f;

		satrec.init = 'y';
		satrec.t = 0.0f;

		// sgp4fix remove satn as it is not needed in initl
		initl(satrec.xke, satrec.j2, satrec.ecco, epoch, satrec.inclo, satrec.no_kozai, satrec.operationmode,
			  ainv, ao, satrec.con41, con42, cosio, cosio2, eccsq, omeosq,
			  posq, rp, rteosq, sinio, satrec.gsto, satrec.no_unkozai);
		satrec.a = powf(satrec.no_unkozai * satrec.tumin, (-2.0f / 3.0f));
		satrec.alta = satrec.a * (1.0f + satrec.ecco) - 1.0f;
		satrec.altp = satrec.a * (1.0f - satrec.ecco) - 1.0f;
		satrec.error = 0;

		// sgp4fix remove this check as it is unnecessary
		// the mrt check in sgp4 handles decaying satellite cases even if the starting
		// condition is below the surface of te earth
		//     if (rp < 1.0f)
		//       {
		//         printf("# *** satn%d epoch elts sub-orbital ***\n", satn);
		//         satrec.error = 5;
		//       }

		if ((omeosq >= 0.0f) || (satrec.no_unkozai >= 0.0f))
		{
			satrec.isimp = 0;
			if (rp < (220.0f / satrec.radiusearthkm + 1.0f))
				satrec.isimp = 1;
			sfour = ss;
			qzms24 = qzms2t;
			perige = (rp - 1.0f) * satrec.radiusearthkm;

			/* - for perigees below 156 km, s and qoms2t are altered - */
			if (perige < 156.0f)
			{
				sfour = perige - 78.0f;
				if (perige < 98.0f)
					sfour = 20.0f;
				// sgp4fix use multiply for speed instead of pow
				qzms24temp = (120.0f - sfour) / satrec.radiusearthkm;
				qzms24 = qzms24temp * qzms24temp * qzms24temp * qzms24temp;
				sfour = sfour / satrec.radiusearthkm + 1.0f;
			}
			pinvsq = 1.0f / posq;

			tsi = 1.0f / (ao - sfour);
			satrec.eta = ao * satrec.ecco * tsi;
			etasq = satrec.eta * satrec.eta;
			eeta = satrec.ecco * satrec.eta;
			psisq = fabsf(1.0f - etasq);
			coef = qzms24 * powf(tsi, 4.0f);
			coef1 = coef / powf(psisq, 3.5f);
			cc2 = coef1 * satrec.no_unkozai * (ao * (1.0f + 1.5f * etasq + eeta * (4.0f + etasq)) + 0.3755f * satrec.j2 * tsi / psisq * satrec.con41 * (8.0f + 3.0f * etasq * (8.0f + etasq)));
			satrec.cc1 = satrec.bstar * cc2;
			cc3 = 0.0f;
			if (satrec.ecco > 1.0e-4f)
				cc3 = -2.0f * coef * tsi * satrec.j3oj2 * satrec.no_unkozai * sinio / satrec.ecco;
			satrec.x1mth2 = 1.0f - cosio2;
			satrec.cc4 = 2.0f * satrec.no_unkozai * coef1 * ao * omeosq *
						 (satrec.eta * (2.0f + 0.5f * etasq) + satrec.ecco * (0.5f + 2.0f * etasq) - satrec.j2 * tsi / (ao * psisq) * (-3.0f * satrec.con41 * (1.0f - 2.0f * eeta + etasq * (1.5f - 0.5f * eeta)) + 0.75f * satrec.x1mth2 * (2.0f * etasq - eeta * (1.0f + etasq)) * cosf(2.0f * satrec.argpo)));
			satrec.cc5 = 2.0f * coef1 * ao * omeosq * (1.0f + 2.75f * (etasq + eeta) + eeta * etasq);
			cosio4 = cosio2 * cosio2;
			temp1 = 1.5f * satrec.j2 * pinvsq * satrec.no_unkozai;
			temp2 = 0.5f * temp1 * satrec.j2 * pinvsq;
			temp3 = -0.46875f * satrec.j4 * pinvsq * pinvsq * satrec.no_unkozai;
			satrec.mdot = satrec.no_unkozai + 0.5f * temp1 * rteosq * satrec.con41 + 0.0625f * temp2 * rteosq * (13.0f - 78.0f * cosio2 + 137.0f * cosio4);
			satrec.argpdot = -0.5f * temp1 * con42 + 0.0625f * temp2 * (7.0f - 114.0f * cosio2 + 395.0f * cosio4) +
							 temp3 * (3.0f - 36.0f * cosio2 + 49.0f * cosio4);
			xhdot1 = -temp1 * cosio;
			satrec.nodedot = xhdot1 + (0.5f * temp2 * (4.0f - 19.0f * cosio2) +
									   2.0f * temp3 * (3.0f - 7.0f * cosio2)) *
										  cosio;
			satrec.omgcof = satrec.bstar * cc3 * cosf(satrec.argpo);
			satrec.xmcof = 0.0f;
			if (satrec.ecco > 1.0e-4f)
				satrec.xmcof = -x2o3 * coef * satrec.bstar / eeta;
			satrec.nodecf = 3.5f * omeosq * xhdot1 * satrec.cc1;
			satrec.t2cof = 1.5f * satrec.cc1;
			// sgp4fix for divide by zero with xinco = 180 deg
			if (fabsf(cosio + 1.0f) > 1.5e-12f)
				satrec.xlcof = -0.25f * satrec.j3oj2 * sinio * (3.0f + 5.0f * cosio) / (1.0f + cosio);
			else
				satrec.xlcof = -0.25f * satrec.j3oj2 * sinio * (3.0f + 5.0f * cosio) / temp4;
			satrec.aycof = -0.5f * satrec.j3oj2 * sinio;
			// sgp4fix use multiply for speed instead of pow
			delmotemp = 1.0f + satrec.eta * cosf(satrec.mo);
			satrec.delmo = delmotemp * delmotemp * delmotemp;
			satrec.sinmao = sinf(satrec.mo);
			satrec.x7thm1 = 7.0f * cosio2 - 1.0f;

			/* ----------- set variables if not deep space ----------- */
			if (satrec.isimp != 1)
			{
				cc1sq = satrec.cc1 * satrec.cc1;
				satrec.d2 = 4.0f * ao * tsi * cc1sq;
				temp = satrec.d2 * tsi * satrec.cc1 / 3.0f;
				satrec.d3 = (17.0f * ao + sfour) * temp;
				satrec.d4 = 0.5f * temp * ao * tsi * (221.0f * ao + 31.0f * sfour) *
							satrec.cc1;
				satrec.t3cof = satrec.d2 + 2.0f * cc1sq;
				satrec.t4cof = 0.25f * (3.0f * satrec.d3 + satrec.cc1 *
															   (12.0f * satrec.d2 + 10.0f * cc1sq));
				satrec.t5cof = 0.2f * (3.0f * satrec.d4 +
									   12.0f * satrec.cc1 * satrec.d3 +
									   6.0f * satrec.d2 * satrec.d2 +
									   15.0f * cc1sq * (2.0f * satrec.d2 + cc1sq));
			}
		} // if omeosq = 0 ...

		/* finally propogate to zero epoch to initialize all others. */
		// sgp4fix take out check to let satellites process until they are actually below earth surface
		//       if(satrec.error == 0)
		sgp4(satrec, 0.0, r, v);

		satrec.init = 'n';

		// #include "debug6.cpp"
		// sgp4fix return boolean. satrec.error contains any error codes
		return true;
	} // sgp4init

	/*-----------------------------------------------------------------------------
	*
	*                             procedure sgp4
	*
	*  this procedure is the sgp4 prediction model from space command. this is an
	*    updated and combined version of sgp4 and sdp4, which were originally
	*    published separately in spacetrack report #3. this version follows the
	*    methodology from the aiaa paper (2006) describing the history and
	*    development of the code.
	*
	*  author        : david vallado                  719-573-2600   28 jun 2005
	*
	*  inputs        :
	*    satrec	 - initialised structure from sgp4init() call.
	*    tsince	 - time since epoch (minutes)
	*
	*  outputs       :
	*    r           - position vector                     km
	*    v           - velocity                            km/sec
	*  return code - non-zero on error.
	*                   1 - mean elements, ecc >= 1.0f or ecc < -0.001 or a < 0.95 er
	*                   2 - mean motion less than 0.0
	*                   3 - pert elements, ecc < 0.0f  or  ecc > 1.0
	*                   4 - semi-latus rectum < 0.0
	*                   5 - epoch elements are sub-orbital
	*                   6 - satellite has decayed
	*
	*  locals        :
	*    am          -
	*    axnl, aynl        -
	*    betal       -
	*    cosim   , sinim   , cosomm  , sinomm  , cnod    , snod    , cos2u   ,
	*    sin2u   , coseo1  , sineo1  , cosi    , sini    , cosip   , sinip   ,
	*    cosisq  , cossu   , sinsu   , cosu    , sinu
	*    delm        -
	*    delomg      -
	*    dndt        -
	*    eccm        -
	*    emsq        -
	*    ecose       -
	*    el2         -
	*    eo1         -
	*    eccp        -
	*    esine       -
	*    argpm       -
	*    argpp       -
	*    omgadf      -c
	*    pl          -
	*    r           -
	*    rtemsq      -
	*    rdotl       -
	*    rl          -
	*    rvdot       -
	*    rvdotl      -
	*    su          -
	*    t2  , t3   , t4    , tc
	*    tem5, temp , temp1 , temp2  , tempa  , tempe  , templ
	*    u   , ux   , uy    , uz     , vx     , vy     , vz
	*    inclm       - inclination
	*    mm          - mean anomaly
	*    nm          - mean motion
	*    nodem       - right asc of ascending node
	*    xinc        -
	*    xincp       -
	*    xl          -
	*    xlm         -
	*    mp          -
	*    xmdf        -
	*    xmx         -
	*    xmy         -
	*    nodedf      -
	*    xnode       -
	*    nodep       -
	*    np          -
	*
	*  coupling      :
	*    getgravconst- no longer used. Variables are conatined within satrec
	*    dpper
	*    dpspace
	*
	*  references    :
	*    hoots, roehrich, norad spacetrack report #3 1980
	*    hoots, norad spacetrack report #6 1986
	*    hoots, schumacher and glover 2004
	*    vallado, crawford, hujsak, kelso  2006
	----------------------------------------------------------------------------*/

	bool sgp4(
		elsetrec &satrec, float tsince,
		float r[3], float v[3])
	{
		// float am, axnl, aynl, betal, cosim, cnod,
		// 	cos2u, coseo1, cosi, cosip, cossu, cosu,
		// 	delm, delomg, em, emsq, ecose, el2, eo1,
		// 	ep, esine, argpm, argpp, argpdf, pl, mrt = 0.0,
		// 										 mvt, rdotl, rl, rvdot, rvdotl, sinim,
		// 										 sin2u, sineo1, sini, sinip, sinsu, sinu,
		// 										 snod, su, t2, t3, t4, tem5, temp,
		// 										 temp1, temp2, tempa, tempe, templ, u, ux,
		// 										 uy, uz, vx, vy, vz, inclm, mm,
		// 										 nm, nodem, xinc, xincp, xl, xlm, mp,
		// 										 xmdf, xmx, xmy, nodedf, xnode, nodep,
		// 										 vkmpersec, delmtemp;
		// int ktr;

		/* ------------------ set mathematical constants --------------- */
		// sgp4fix divisor for divide by zero check on inclination
		// the old check used 1.0f + cosf(pi-1.0e-9), but then compared it to
		// 1.5f e-12, so the threshold was changed to 1.5e-12 for consistency
		constexpr float twopi = 2.0f * pi;
		constexpr float x2o3 = 2.0f / 3.0f;
		// sgp4fix identify constants and allow alternate values
		// getgravconst( whichconst, tumin, mu, radiusearthkm, xke, j2, j3, j4, j3oj2 );
		float vkmpersec = satrec.radiusearthkm * satrec.xke / 60.0f;

		/* --------------------- clear sgp4 error flag ----------------- */
		satrec.t = tsince;
		satrec.error = 0;

		/* ------- update for secular gravity and atmospheric drag ----- */
		float xmdf = satrec.mo + satrec.mdot * satrec.t;
		float argpdf = satrec.argpo + satrec.argpdot * satrec.t;
		float nodedf = satrec.nodeo + satrec.nodedot * satrec.t;
		// float argpm = argpdf;
		// float mm = xmdf;
		float t2 = satrec.t * satrec.t;
		float nodem = nodedf + satrec.nodecf * t2;
		float tempa = 1.0f - satrec.cc1 * satrec.t;
		float tempe = satrec.bstar * satrec.cc4 * satrec.t;
		float templ = satrec.t2cof * t2;

		float delomg = satrec.omgcof * satrec.t;
		// sgp4fix use mutliply for speed instead of pow
		float delmtemp = 1.0f + satrec.eta * cosf(xmdf);
		float delm = satrec.xmcof *
					 (delmtemp * delmtemp * delmtemp -
					  satrec.delmo);
		float temp = delomg + delm;
		float mm = xmdf + temp;
		float argpm = argpdf - temp;
		float t3 = t2 * satrec.t;
		float t4 = t3 * satrec.t;
		tempa = tempa - satrec.d2 * t2 - satrec.d3 * t3 -
				satrec.d4 * t4;
		tempe = tempe + satrec.bstar * satrec.cc5 * (sinf(mm) - satrec.sinmao);
		templ = templ + satrec.t3cof * t3 + t4 * (satrec.t4cof + satrec.t * satrec.t5cof);

		float nm = satrec.no_unkozai;
		float em = satrec.ecco;
		float inclm = satrec.inclo;

		if (nm <= 0.0f)
		{
			//         printf("# error nm %f\n", nm);
			satrec.error = 2;
			// sgp4fix add return
			return false;
		}
		float am = powf((satrec.xke / nm), x2o3) * tempa * tempa;
		nm = satrec.xke / powf(am, 1.5f);
		em = em - tempe;

		// fix tolerance for error recognition
		// sgp4fix am is fixed from the previous nm check
		if ((em >= 1.0f) || (em < -0.001f) /* || (am < 0.95f)*/)
		{
			//         printf("# error em %f\n", em);
			satrec.error = 1;
			// sgp4fix to return if there is an error in eccentricity
			return false;
		}
		// sgp4fix fix tolerance to avoid a divide by zero
		if (em < 1.0e-6f)
			em = 1.0e-6f;
		mm = mm + satrec.no_unkozai * templ;
		float xlm = mm + argpm + nodem;
		float emsq = em * em;
		temp = 1.0f - emsq;

		nodem = fmod(nodem, twopi);
		argpm = fmod(argpm, twopi);
		xlm = fmod(xlm, twopi);
		mm = fmod(xlm - argpm - nodem, twopi);

		// sgp4fix recover singly averaged mean elements
		satrec.am = am;
		satrec.em = em;
		satrec.im = inclm;
		satrec.Om = nodem;
		satrec.om = argpm;
		satrec.mm = mm;
		satrec.nm = nm;

		/* ----------------- compute extra mean quantities ------------- */
		float sinim = sinf(inclm);
		float cosim = cosf(inclm);

		/* -------------------- add lunar-solar periodics -------------- */
		float ep = em;
		float xincp = inclm;
		float argpp = argpm;
		float nodep = nodem;
		float mp = mm;
		float sinip = sinim;
		float cosip = cosim;

		float axnl = ep * cosf(argpp);
		temp = 1.0f / (am * (1.0f - ep * ep));
		float aynl = ep * sinf(argpp) + temp * satrec.aycof;
		float xl = mp + argpp + nodep + temp * satrec.xlcof * axnl;

		/* --------------------- solve kepler's equation --------------- */
		float u = fmod(xl - nodep, twopi);
		float eo1 = u;
		constexpr float tem5 = 9999.9f;
		int ktr = 1;
		//   sgp4fix for kepler iteration
		//   the following iteration needs better limits on corrections
		float sineo1, coseo1;
		while ((fabsf(tem5) >= 1.0e-12f) && (ktr <= 10))
		{
			sineo1 = sinf(eo1);
			coseo1 = cosf(eo1);
			float tem5 = 1.0f - coseo1 * axnl - sineo1 * aynl;
			tem5 = (u - aynl * coseo1 + axnl * sineo1 - eo1) / tem5;
			if (fabsf(tem5) >= 0.95f)
				tem5 = tem5 > 0.0f ? 0.95f : -0.95f;
			eo1 = eo1 + tem5;
			ktr = ktr + 1;
		}

		/* ------------- short period preliminary quantities ----------- */
		float ecose = axnl * coseo1 + aynl * sineo1;
		float esine = axnl * sineo1 - aynl * coseo1;
		float el2 = axnl * axnl + aynl * aynl;
		float pl = am * (1.0f - el2);
		float rvdotl, mrt;
		if (pl < 0.0f)
		{
			//         printf("# error pl %f\n", pl);
			satrec.error = 4;
			// sgp4fix add return
			return false;
		}
		else
		{
			float rl = am * (1.0f - ecose);
			float rdotl = sqrtf(am) * esine / rl;
			rvdotl = sqrtf(pl) / rl;
			float betal = sqrtf(1.0f - el2);
			float temp = esine / (1.0f + betal);
			float sinu = am / rl * (sineo1 - aynl - axnl * temp);
			float cosu = am / rl * (coseo1 - axnl + aynl * temp);
			float su = atan2f(sinu, cosu);
			float sin2u = (cosu + cosu) * sinu;
			float cos2u = 1.0f - 2.0f * sinu * sinu;
			float temp0 = 1.0f / pl;
			float temp1 = 0.5f * satrec.j2 * temp0;
			float temp2 = temp1 * temp0;

			/* -------------- update for short period periodics ------------ */
			mrt = rl * (1.0f - 1.5f * temp2 * betal * satrec.con41) +
				  0.5f * temp1 * satrec.x1mth2 * cos2u;
			su = su - 0.25f * temp2 * satrec.x7thm1 * sin2u;
			float xnode = nodep + 1.5f * temp2 * cosip * sin2u;
			float xinc = xincp + 1.5f * temp2 * cosip * sinip * cos2u;
			float mvt = rdotl - nm * temp1 * satrec.x1mth2 * sin2u / satrec.xke;
			float rvdot = rvdotl + nm * temp1 * (satrec.x1mth2 * cos2u + 1.5f * satrec.con41) / satrec.xke;

			/* --------------------- orientation vectors ------------------- */
			float sinsu = sinf(su);
			float cossu = cosf(su);
			float snod = sinf(xnode);
			float cnod = cosf(xnode);
			float sini = sinf(xinc);
			float cosi = cosf(xinc);
			float xmx = -snod * cosi;
			float xmy = cnod * cosi;
			float ux = xmx * sinsu + cnod * cossu;
			float uy = xmy * sinsu + snod * cossu;
			float uz = sini * sinsu;
			float vx = xmx * cossu - cnod * sinsu;
			float vy = xmy * cossu - snod * sinsu;
			float vz = sini * cossu;

			/* --------- position and velocity (in km and km/sec) ---------- */
			r[0] = (mrt * ux) * satrec.radiusearthkm;
			r[1] = (mrt * uy) * satrec.radiusearthkm;
			r[2] = (mrt * uz) * satrec.radiusearthkm;
			v[0] = (mvt * ux + rvdot * vx) * vkmpersec;
			v[1] = (mvt * uy + rvdot * vy) * vkmpersec;
			v[2] = (mvt * uz + rvdot * vz) * vkmpersec;
		} // if pl > 0

		// sgp4fix for decaying satellites
		if (mrt < 1.0f)
		{
			//         printf("# decay condition %11.6f \n",mrt);
			satrec.error = 6;
			return false;
		}

		// #include "debug7.cpp"
		return true;
	} // sgp4

	/* -----------------------------------------------------------------------------
	*
	*                           function getgravconst
	*
	*  this function gets constants for the propagator. note that mu is identified to
	*    facilitiate comparisons with newer models. the common useage is wgs72.
	*
	*  author        : david vallado                  719-573-2600   21 jul 2006
	*
	*  inputs        :
	*    whichconst  - which set of constants to use  wgs72old, wgs72, wgs84
	*
	*  outputs       :
	*    tumin       - minutes in one time unit
	*    mu          - earth gravitational parameter
	*    radiusearthkm - radius of the earth in km
	*    xke         - reciprocal of tumin
	*    j2, j3, j4  - un-normalized zonal harmonic values
	*    j3oj2       - j3 divided by j2
	*
	*  locals        :
	*
	*  coupling      :
	*    none
	*
	*  references    :
	*    norad spacetrack report #3
	*    vallado, crawford, hujsak, kelso  2006
	--------------------------------------------------------------------------- */

	void getgravconst(
		gravconsttype whichconst,
		float &tumin,
		float &mus,
		float &radiusearthkm,
		float &xke,
		float &j2,
		float &j3,
		float &j4,
		float &j3oj2)
	{

		switch (whichconst)
		{
			// -- wgs-72 low precision str#3 constants --
		case wgs72old:
			mus = 398600.79964f;	   // in km3 / s2
			radiusearthkm = 6378.135f; // km
			xke = 0.0743669161f;	   // reciprocal of tumin
			tumin = 1.0f / xke;
			j2 = 0.001082616f;
			j3 = -0.00000253881f;
			j4 = -0.00000165597f;
			j3oj2 = j3 / j2;
			break;
			// ------------ wgs-72 constants ------------
		case wgs72:
			mus = 398600.8f;		   // in km3 / s2
			radiusearthkm = 6378.135f; // km
			xke = 60.0f / sqrtf(radiusearthkm * radiusearthkm * radiusearthkm / mus);
			tumin = 1.0f / xke;
			j2 = 0.001082616f;
			j3 = -0.00000253881f;
			j4 = -0.00000165597f;
			j3oj2 = j3 / j2;
			break;
		case wgs84:
			// ------------ wgs-84 constants ------------
			mus = 398600.5f;		   // in km3 / s2
			radiusearthkm = 6378.137f; // km
			xke = 60.0f / sqrtf(radiusearthkm * radiusearthkm * radiusearthkm / mus);
			tumin = 1.0f / xke;
			j2 = 0.00108262998905f;
			j3 = -0.00000253215306f;
			j4 = -0.00000161098761f;
			j3oj2 = j3 / j2;
			break;
		default:
			fprintf(stderr, "unknown gravity option (%d)\n", whichconst);
			break;
		}

	} // getgravconst

	// older sgp4io methods
	/* -----------------------------------------------------------------------------
	*
	*                           function twoline2rv
	*
	*  this function converts the two line element set character string data to
	*    variables and initializes the sgp4 variables. several intermediate varaibles
	*    and quantities are determined. note that the result is a structure so multiple
	*    satellites can be processed simaltaneously without having to reinitialize. the
	*    verification mode is an important option that permits quick checks of any
	*    changes to the underlying technical theory. this option works using a
	*    modified tle file in which the start, stop, and delta time values are
	*    included at the end of the second line of data. this only works with the
	*    verification mode. the catalog mode simply propagates from -1440 to 1440 min
	*    from epoch and is useful when performing entire catalog runs.
	*    update for alpha 5 numbering system. 4 mar 2021.
	*    update to check and not process if ephtype = 4 (sgp4-xp tle)
	*
	*  author        : david vallado                                  29 aug 2024
	*
	*  inputs        :
	*    longstr1    - first line of the tle
	*    longstr2    - second line of the tle
	*    typerun     - type of run                    verification 'v', catalog 'c',
	*                                                 manual 'm'
	*    typeinput   - type of manual input           mfe 'm', epoch 'e', dayofyr 'd'
	*    opsmode     - mode of operation afspc or improved 'a', 'i'
	*    whichconst  - which set of constants to use  72, 84
	*
	*  outputs       :
	*    satrec      - structure containing all the sgp4 satellite information
	*
	*  coupling      :
	*    getgravconst-
	*    days2mdhms  - conversion of days to month, day, hour, minute, second
	*    jday        - convert day month year hour minute second into julian date
	*    sgp4init    - initialize the sgp4 variables
	*
	*  references    :
	*    norad spacetrack report #3
	*    vallado, crawford, hujsak, kelso  2006
	--------------------------------------------------------------------------- */

	void twoline2rv(
		char longstr1[130], char longstr2[130],
		char typerun, char typeinput, char opsmode,
		gravconsttype whichconst,
		float &startmfe, float &stopmfe, float &deltamin,
		elsetrec &satrec)
	{
		constexpr float deg2rad = pi / 180.0f;			//   0.0174532925199433
		constexpr float xpdotp = 1440.0f / (2.0f * pi); // 229.1831180523293

		float sec;
		float startsec, stopsec, startdayofyr, stopdayofyr, jdstart, jdstop, jdstartF, jdstopF;
		int startyear, stopyear, startmon, stopmon, startday, stopday,
			starthr, stophr, startmin, stopmin;
		int cardnumb, j;
		// sgp4fix include in satrec
		// long revnum = 0, elnum = 0;
		// char classification, intldesg[11];
		int year = 0;
		int mon, day, hr, minute, nexp, ibexp;

		// sgp4fix no longer needed
		// getgravconst( whichconst, tumin, mu, radiusearthkm, xke, j2, j3, j4, j3oj2 );

		satrec.error = 0;

		// set the implied decimal points since doing a formated read
		// fixes for bad input data values (missing, ...)
		for (j = 10; j <= 15; j++)
			if (longstr1[j] == ' ')
				longstr1[j] = '_';

		if (longstr1[44] != ' ')
			longstr1[43] = longstr1[44];
		longstr1[44] = '.';
		if (longstr1[7] == ' ')
			longstr1[7] = 'U';
		if (longstr1[9] == ' ')
			longstr1[9] = '.';
		for (j = 45; j <= 49; j++)
			if (longstr1[j] == ' ')
				longstr1[j] = '0';
		if (longstr1[51] == ' ')
			longstr1[51] = '0';
		if (longstr1[53] != ' ')
			longstr1[52] = longstr1[53];
		longstr1[53] = '.';
		longstr2[25] = '.';
		for (j = 26; j <= 32; j++)
			if (longstr2[j] == ' ')
				longstr2[j] = '0';
		if (longstr1[62] == ' ')
			longstr1[62] = '0';
		if (longstr1[68] == ' ')
			longstr1[68] = '0';
		sscanf(longstr1, "%2d %5s %1c %10s %2d %12f %11f %7f %2d %7f %2d %2d %6ld ",
			   &cardnumb, satrec.satnum, &satrec.classification, satrec.intldesg, &satrec.epochyr,
			   &satrec.epochdays, &satrec.ndot, &satrec.nddot, &nexp, &satrec.bstar,
			   &ibexp, &satrec.ephtype, &satrec.elnum);

		// sgp4fix note that the ephtype must be 0 for SGP4. SGP4-XP uses 4.
		if (satrec.ephtype == 0)
		{
			if (longstr2[52] == ' ')
			{
				if (typerun == 'v') // run for specified times from the file
				{
					sscanf(longstr2, "%2d %5s %9f %9f %8f %9f %9f %10f %6ld %f %f %f \n",
						   &cardnumb, satrec.satnum, &satrec.inclo,
						   &satrec.nodeo, &satrec.ecco, &satrec.argpo, &satrec.mo, &satrec.no_kozai,
						   &satrec.revnum, &startmfe, &stopmfe, &deltamin);
				}
				else // simply run -1 day to +1 day or user input times
				{
					sscanf(longstr2, "%2d %5s %9f %9f %8f %9f %9f %10f %6ld \n",
						   &cardnumb, satrec.satnum, &satrec.inclo,
						   &satrec.nodeo, &satrec.ecco, &satrec.argpo, &satrec.mo, &satrec.no_kozai,
						   &satrec.revnum);
				}
			}
			else if (typerun == 'v') // run for specified times from the file
			{
				sscanf(longstr2, "%2d %5s %9f %9f %8f %9f %9f %11f %6ld %f %f %f \n",
					   &cardnumb, satrec.satnum, &satrec.inclo,
					   &satrec.nodeo, &satrec.ecco, &satrec.argpo, &satrec.mo, &satrec.no_kozai,
					   &satrec.revnum, &startmfe, &stopmfe, &deltamin);
			}
			else // simply run -1 day to +1 day or user input times
			{
				sscanf(longstr2, "%2d %5s %9f %9f %8f %9f %9f %11f %6ld \n",
					   &cardnumb, satrec.satnum, &satrec.inclo,
					   &satrec.nodeo, &satrec.ecco, &satrec.argpo, &satrec.mo, &satrec.no_kozai,
					   &satrec.revnum);
			}

			// ---- find no, ndot, nddot ----
			satrec.no_kozai = satrec.no_kozai / xpdotp; //* rad/min
			satrec.nddot = satrec.nddot * powf(10.0f, (float)nexp);
			// could multiply by 0.00001, but implied decimal is set in the longstr1 above
			satrec.bstar = satrec.bstar * powf(10.0f, (float)ibexp);

			// ---- convert to sgp4 units ----
			// satrec.a    = powf( satrec.no_kozai*tumin , (-2.0/3.0f) );
			satrec.ndot = satrec.ndot / (xpdotp * 1440.0f); //* ? * minperday
			satrec.nddot = satrec.nddot / (xpdotp * 1440.0f * 1440);

			// ---- find standard orbital elements ----
			satrec.inclo = satrec.inclo * deg2rad;
			satrec.nodeo = satrec.nodeo * deg2rad;
			satrec.argpo = satrec.argpo * deg2rad;
			satrec.mo = satrec.mo * deg2rad;

			// sgp4fix not needed here
			// satrec.alta = satrec.a*(1.0f + satrec.ecco) - 1.0f;
			// satrec.altp = satrec.a*(1.0f - satrec.ecco) - 1.0f;

			// ----------------------------------------------------------------
			// find sgp4epoch time of element set
			// remember that sgp4 uses units of days from 0 jan 1950 (sgp4epoch)
			// and minutes from the epoch (time)
			// ----------------------------------------------------------------

			// ---------------- temp fix for years from 1957-2056 -------------------
			// --------- correct fix will occur when year is 4-digit in tle ---------
			if (satrec.epochyr < 57)
				year = satrec.epochyr + 2000;
			else
				year = satrec.epochyr + 1900;

			days2mdhms_SGP4(year, satrec.epochdays, mon, day, hr, minute, sec);
			jday_SGP4(year, mon, day, hr, minute, sec, satrec.jdsatepoch, satrec.jdsatepochF);

			// ---- input start stop times manually
			if ((typerun != 'v') && (typerun != 'c'))
			{
				// ------------- enter start/stop ymd hms values --------------------
				if (typeinput == 'e')
				{
					printf("input start prop year mon day hr min sec \n");
					// make sure there is no space at the end of the format specifiers in scanf!
					scanf("%i %i %i %i %i %f", &startyear, &startmon, &startday, &starthr, &startmin, &startsec);
					fflush(stdin);
					jday_SGP4(startyear, startmon, startday, starthr, startmin, startsec, jdstart, jdstartF);

					printf("input stop prop year mon day hr min sec \n");
					scanf("%i %i %i %i %i %f", &stopyear, &stopmon, &stopday, &stophr, &stopmin, &stopsec);
					fflush(stdin);
					jday_SGP4(stopyear, stopmon, stopday, stophr, stopmin, stopsec, jdstop, jdstopF);

					startmfe = (jdstart - satrec.jdsatepoch) * 1440.0f + (jdstartF - satrec.jdsatepochF) * 1440.0f;
					stopmfe = (jdstop - satrec.jdsatepoch) * 1440.0f + (jdstopF - satrec.jdsatepochF) * 1440.0f;

					printf("input time step in minutes \n");
					scanf("%f", &deltamin);
				}
				// -------- enter start/stop year and days of year values -----------
				if (typeinput == 'd')
				{
					printf("input start year dayofyr \n");
					scanf("%i %f", &startyear, &startdayofyr);
					printf("input stop year dayofyr \n");
					scanf("%i %f", &stopyear, &stopdayofyr);

					days2mdhms_SGP4(startyear, startdayofyr, mon, day, hr, minute, sec);
					jday_SGP4(startyear, mon, day, hr, minute, sec, jdstart, jdstartF);
					days2mdhms_SGP4(stopyear, stopdayofyr, mon, day, hr, minute, sec);
					jday_SGP4(stopyear, mon, day, hr, minute, sec, jdstop, jdstopF);

					startmfe = (jdstart - satrec.jdsatepoch) * 1440.0f + (jdstartF - satrec.jdsatepochF) * 1440.0f;
					stopmfe = (jdstop - satrec.jdsatepoch) * 1440.0f + (jdstopF - satrec.jdsatepochF) * 1440.0f;

					printf("input time step in minutes \n");

					scanf("%f", &deltamin);
				}
				// ------------------ enter start/stop mfe values -------------------
				if (typeinput == 'm')
				{
					printf("input start min from epoch \n");
					scanf("%f", &startmfe);
					printf("input stop min from epoch \n");
					scanf("%f", &stopmfe);
					printf("input time step in minutes \n");
					scanf("%f", &deltamin);
				}
			}

			// ------------ perform complete catalog evaluation, -+ 1 day -----------
			if (typerun == 'c')
			{
				startmfe = -1440.0f;
				stopmfe = 1440.0f;
				deltamin = 10.0f;
			}

			// ---------------- initialize the orbit at sgp4epoch -------------------
			sgp4init(whichconst, opsmode, satrec.satnum, (satrec.jdsatepoch + satrec.jdsatepochF) - 2433281.5f, satrec.bstar,
					 satrec.ndot, satrec.nddot, satrec.ecco, satrec.argpo, satrec.inclo, satrec.mo, satrec.no_kozai,
					 satrec.nodeo, satrec);
		} // if ephtype == 0
	} // twoline2rv

	// older sgp4ext methods
	/* -----------------------------------------------------------------------------
	 *
	 *                           function gstime_SGP4
	 *
	 *  this function finds the greenwich sidereal time.
	 *
	 *  author        : david vallado                  719-573-2600    1 mar 2001
	 *
	 *  inputs          description                    range / units
	 *    jdut1       - julian date in ut1             days from 4713 bc
	 *
	 *  outputs       :
	 *    gstime      - greenwich sidereal time        0 to 2pi rad
	 *
	 *  locals        :
	 *    temp        - temporary variable for floats   rad
	 *    tut1        - julian centuries from the
	 *                  jan 1, 2000 12 h epoch (ut1)
	 *
	 *  coupling      :
	 *    none
	 *
	 *  references    :
	 *    vallado       2013, 187, eq 3-45
	 * --------------------------------------------------------------------------- */

	float gstime_SGP4(
		float jdut1)
	{
		constexpr float twopi = 2.0f * pi;
		constexpr float deg2rad = pi / 180.0f;
		float temp, tut1;

		tut1 = (jdut1 - 2451545.0f) / 36525.0f;
		temp = -6.2e-6f * tut1 * tut1 * tut1 + 0.093104f * tut1 * tut1 +
			   (876600.0f * 3600.f + 8640184.812866f) * tut1 + 67310.54841f; // sec
		temp = fmod(temp * deg2rad / 240.0f, twopi);						 // 360/86400 = 1/240, to deg, to rad

		// ------------------------ check quadrants ---------------------
		if (temp < 0.0f)
			temp += twopi;

		return temp;
	} // gstime

	/* -----------------------------------------------------------------------------
	 *
	 *                           procedure jday_SGP4
	 *
	 *  this procedure finds the julian date given the year, month, day, and time.
	 *    the julian date is defined by each elapsed day since noon, jan 1, 4713 bc.
	 *
	 *  algorithm     : calculate the answer in one step for efficiency
	 *
	 *  author        : david vallado                  719-573-2600    1 mar 2001
	 *
	 *  inputs          description                    range / units
	 *    year        - year                           1900 .. 2100
	 *    mon         - month                          1 .. 12
	 *    day         - day                            1 .. 28,29,30,31
	 *    hr          - universal time hour            0 .. 23
	 *    min         - universal time min             0 .. 59
	 *    sec         - universal time sec             0.0f .. 59.999
	 *
	 *  outputs       :
	 *    jd          - julian date                    days from 4713 bc
	 *    jdfrac      - julian date fraction into day  days from 4713 bc
	 *
	 *  locals        :
	 *    none.
	 *
	 *  coupling      :
	 *    none.
	 *
	 *  references    :
	 *    vallado       2013, 183, alg 14, ex 3-4
	 * --------------------------------------------------------------------------- */

	void jday_SGP4(
		int year, int mon, int day, int hr, int minute, float sec,
		float &jd, float &jdFrac)
	{
		jd = 367.0f * (float)year -
			 floorf((7 * ((float)year + floorf(((float)mon + 9) / 12.0f))) * 0.25f) +
			 floorf(275.f * (float)mon / 9.0f) +
			 (float)day + 1721013.5f; // use - 678987.0f to go to mjd directly
		jdFrac = ((float)sec + (float)minute * 60.0f + (float)hr * 3600.0f) / 86400.0f;

		// check that the day and fractional day are correct
		if (fabsf(jdFrac) > 1.0f)
		{
			float dtt = floorf(jdFrac);
			jd = jd + dtt;
			jdFrac = jdFrac - dtt;
		}

		// - 0.5*sgn(100.0*year + mon - 190002.5f) + 0.5f;
	} // jday

	/* -----------------------------------------------------------------------------
	 *
	 *                           procedure days2mdhms_SGP4
	 *
	 *  this procedure converts the day of the year, days, to the equivalent month
	 *    day, hour, minute and second.
	 *
	 *  algorithm     : set up array for the number of days per month
	 *                  find leap year - use 1900 because 2000 is a leap year
	 *                  loop through a temp value while the value is < the days
	 *                  perform int conversions to the correct day and month
	 *                  convert remainder into h m s using type conversions
	 *
	 *  author        : david vallado                  719-573-2600    1 mar 2001
	 *
	 *  inputs          description                    range / units
	 *    year        - year                           1900 .. 2100
	 *    days        - julian day of the year         1.0f  .. 366.0
	 *
	 *  outputs       :
	 *    mon         - month                          1 .. 12
	 *    day         - day                            1 .. 28,29,30,31
	 *    hr          - hour                           0 .. 23
	 *    min         - minute                         0 .. 59
	 *    sec         - second                         0.0f .. 59.999
	 *
	 *  locals        :
	 *    dayofyr     - day of year
	 *    temp        - temporary extended values
	 *    inttemp     - temporary int value
	 *    i           - index
	 *    lmonth[13]  - int array containing the number of days per month
	 *
	 *  coupling      :
	 *    none.
	 * --------------------------------------------------------------------------- */

	void days2mdhms_SGP4(
		int year, float days,
		int &mon, int &day, int &hr, int &minute, float &sec)
	{
		int i, inttemp, dayofyr;
		float temp;
		int lmonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

		dayofyr = (int)floorf(days);
		/* ----------------- find month and day of month ---------------- */
		if ((year % 4) == 0)
			lmonth[2] = 29;

		i = 1;
		inttemp = 0;
		while ((i < 12) && (dayofyr > inttemp + lmonth[i]))
		{
			inttemp = inttemp + lmonth[i];
			i++;
		}
		mon = i;
		day = dayofyr - inttemp;

		/* ----------------- find hours minutes and seconds ------------- */
		temp = (days - (float)dayofyr) * 24.0f;
		hr = (int)floorf(temp);
		temp = (temp - (float)hr) * 60.0f;
		minute = (int)floorf(temp);
		sec = (temp - (float)minute) * 60.0f;
	} // days2mdhms

} // namespace SGP4Funcs
